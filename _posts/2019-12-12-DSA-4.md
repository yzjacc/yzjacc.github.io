---

layout: post
title: "「DSA」数据结构与算法 图论"
subtitle: " From Yuzj"
author: "Yuzj"
header-img: "img/post-bg-web.jpg"
header-mask: 0.3
catalog: true
tags:
- 数据结构与算法
- Javascript
---

## 图

### 最小生成树问题

![屏幕快照 2019-12-10 下午2.38.26](https://pg12138.oss-cn-beijing.aliyuncs.com/img/in-post/2019-12-12/屏幕快照 2019-12-12 下午2.28.00.png)

```javascript
function Node(value) {
    this.value = value;
    this.left = null;
    this.right = null;
}

var a = new Node("a");
var b = new Node("b");
var c = new Node("c");
var d = new Node("d");
var e = new Node("e");
var f = new Node("f");
var g = new Node("g");

a.left = c;
a.right = b;
c.left = f;
c.right = g;
b.left = d;
b.right = e;

//对于二叉树来说，深度优先搜索，和前序遍历的顺序是一样的。
function deepSearch(root, target) {
    if (root == null) return false;
    if (root.value == target) return true;
    var left = deepSearch(root.left, target);
    var right = deepSearch(root.right, target);
    return left || right;
}

console.log(deepSearch(a, "n"));
```

### 广度优先搜索

```javascript
function Node(value) {
    this.value = value;
    this.left = null;
    this.right = null;
}

var a = new Node("a");
var b = new Node("b");
var c = new Node("c");
var d = new Node("d");
var e = new Node("e");
var f = new Node("f");
var g = new Node("g");

a.left = c;
a.right = b;
c.left = f;
c.right = g;
b.left = d;
b.right = e;

function f1(rootList, target) {
    if (rootList == null || rootList.length == 0) return false;
    var childList = [];//当前层所有节点的子节点，都在这个list中，这样传入下一层级的时候，就可以遍历整个层级的节点。
    for (var i = 0 ; i < rootList.length ; i ++) {
        if (rootList[i] != null && rootList[i].value == target) {
            return true;
        } else {
            childList.push(rootList[i].left);
            childList.push(rootList[i].right);
        }
    }
    return f1(childList, target);
}


console.log(f1([a], "e"));
```

### 二叉树的比较

![屏幕快照4](https://pg12138.oss-cn-beijing.aliyuncs.com/img/in-post/2019-12-11/屏幕快照 2019-12-12 下午3.05.49.png)

**左右子树交换后不算相同二叉树** 笔试默认 面试要问一下

```js
function Node(value) {
    this.value = value;
    this.left = null;
    this.right = null;
}

var a1 = new Node("a");
var b1 = new Node("b");
var c1 = new Node("c");
var d1 = new Node("d");
var e1 = new Node("e");
var f1 = new Node("f");
var g1 = new Node("g");

a1.left = c1;
a1.right = b1;
c1.left = f1;
// c1.right = g1;
b1.left = d1;
b1.right = e1;

var a2 = new Node("a");
var b2 = new Node("b");
var c2 = new Node("c");
var d2 = new Node("d");
var e2 = new Node("e");
var f2 = new Node("f");
var g2 = new Node("g");

a2.left = c2;
a2.right = b2;
c2.left = f2;
// c2.right = g2;
b2.left = d2;
b2.right = e2;

function compareTree(root1, root2) {
    if (root1 == root2) return true;//是同一个颗树
    if (root1 == null && root2 != null || root2 == null && root1 != null) return false;//其中一个为空，另一个不为空
    if (root1.value != root2.value) return false;//相同位置的值不相等
    var leftBool = compareTree(root1.left, root2.left);//判断左子树是否相等
    var rightBool = compareTree(root1.right, root2.right);//判断右子树是否相等
    return leftBool && rightBool;//必须左右子树都相等才算相等
}

console.log(compareTree(a1, a2));
```

**左右子树交换后不算相同二叉树**

```js
function Node(value) {
    this.value = value;
    this.left = null;
    this.right = null;
}

var a1 = new Node("a");
var b1 = new Node("b");
var c1 = new Node("c");
var d1 = new Node("d");
var e1 = new Node("e");
var f1 = new Node("f");
var g1 = new Node("g");

a1.left = c1;
a1.right = b1;
c1.left = f1;
c1.right = g1;
b1.left = d1;
b1.right = e1;

var a2 = new Node("a");
var b2 = new Node("b");
var c2 = new Node("c");
var d2 = new Node("d");
var e2 = new Node("e");
var f2 = new Node("f");
var g2 = new Node("g");

a2.right = c2;
a2.left = b2;
c2.left = f2;
c2.right = g2;
b2.left = d2;
b2.right = e2;

function compareTree(root1, root2) {
    if (root1 == root2) return true;//是同一个颗树
    if (root1 == null && root2 != null || root2 == null && root1 != null) return false;//其中一个为空，另一个不为空
    if (root1.value != root2.value) return false;//相同位置的值不相等
    return compareTree(root1.left, root2.left) && compareTree(root1.right, root2.right)
    || compareTree(root1.left, root2.right) && compareTree(root1.right, root2.left);
}

console.log(compareTree(a1, a2));
```

### 二叉树的diff算法

![](https://pg12138.oss-cn-beijing.aliyuncs.com/img/in-post/2019-12-10/屏幕快照 2019-12-11 下午12.08.40.png)

