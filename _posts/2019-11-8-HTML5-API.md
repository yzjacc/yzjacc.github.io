---
layout: post
title: "「HTML」HTML5 API篇"
subtitle: " From Yuzj"
author: "Yuzj"
header-img: "img/post-bg-web.jpg"
header-mask: 0.3
catalog: true
tags:
- HTML
- HTML5

---

### 1.地理定位信息 geolocation

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
  </head>
  <body>
    <script>
      // 获取地理信息
      // 一些操作系统，不支持这些功能
      // 定位（gps）。台式机几乎没有GPS，笔记本绝大多数没有GPS，智能手机都有
      // 所以计算机一般通过基站网络 来粗略获取地理信息位置。
      window.navigator.geolocation.getCurrentPosition(
        function(position) {
          console.log(position);
        },
        function(position) {
          console.log(position);
        }
      );
      // 一个成功后函数 一个失败后执行
      // 该函数必须在https/file协议下才能运行 http不能运行
      // 两个属性 latitude属性是纬度 longitude是经度
    </script>
  </body>
</html>

```

### 2.开服务器 这样可以利用手机登陆

```javascript
var express = require("express");
var app = new express();
app.use(express.static("./page"));
app.listen(12306);// 端口号一般大于8000、等于80
// 利用终端开启 node server.js
// webstorm 开启 右键 run server.js
```

### 3.重力感应 deviceorientation

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
  </head>
  <body>
    <script>
      // 只有带有陀螺仪的设备 才支持该API
      // 苹果设备只有https协议情况下才能使用该接口
      // ios 11.1.x以及之前，可以使用

      // alpha: 指北 [0,360) 0的时候指北
      // beta: 手机平放时候为0。手机立起来（短边在桌面） 为			// 90 倒立为-90。
      // gamma: 手机平放时候为0。手机立起来（长边在桌面） 为			 // 90 倒立为-90。

      window.addEventListener("deviceorientation",function(event){
        console.log(event);
      });

    </script>
  </body>
</html>

```

### 4.手机访问电脑

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
  </head>
  <body>
    <div id="main"></div>
    <script>
      // 只有带有陀螺仪的设备 才支持该API
      // 苹果设备只有https协议情况下才能使用该接口
      // ios 11.1.x以及之前，可以使用

      // alpha: 指北 [0,360) 0的时候指北
      // beta: 手机平放时候为0。手机立起来（短边在桌面） 为90 倒立为-90。
      // gamma: 手机平放时候为0。手机立起来（长边在桌面） 为90 倒立为-90。

      window.addEventListener("deviceorientation",function(event){
        document.getElementById('main').innerHTML= 'alpha'=event.alpha;
      });
      //1. 手机要和电脑在同一个局域网下
      //2. 获取电脑的ip地址
      //3. 在手机上输入相应的ip和端口进行访问
      // mac获取ip方法 ifconfig |grep "inet" 找inet 本机ip地址
      // windows方法 ipconfig 插网线找以太网 wifi找局域网
      // 如果win访问不了 修改防火墙权限
      </script>
  </body>
</html>

```

### 5.加速度 devicemotion

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
  </head>
  <body>
    <div id="main"></div>
    <script>
      // 只有带有陀螺仪的设备 才支持该API
      // 苹果设备只有https协议情况下才能使用该接口
      // ios 11.1.x以及之前，可以使用

      // xyz的加速度
      window.addEventListener("devicemotion",function(event){
        document.getElementById('main').innerHTML= event.acceleration.x;
        document.getElementById('main').innerHTML= event.acceleration.y;
        document.getElementById('main').innerHTML= event.acceleration.z;
      });

      </script>
  </body>
</html>

```

### 6.requestAnimationFrame

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
  </head>
  <body>
    <script>
      var timer = null;
      function move() {
        var square = document.getElementById("main");
        if (square.offsetLeft > 700) {
          // return;
          cancelAnimationFrame(timer);
          // cancelAnimationFrame 与 clearTimeout 类似
        }
        square.style.left = square.offsetLeft + 20 + "px";
        timer = requestAnimationFrame(move);
      }
      move();
      // setInterval(move,10);
      // 定时器存在弊端 显示器刷新频率 60HZ 屏幕每秒闪60次
      // 如果一秒超过60次 就会有一些动画帧会被丢掉 就会有类似卡顿的视觉效果
      // 为了优化这种情况requestAnimationFrame（兼容性不好）
      // requestAnimationFrame是刚好每秒60帧

      // 但是如果将setInterval 设置每秒60帧 该方法每帧执行事件少于（1/60）秒
      // requestAnimationFrame 是采用与上种不一样的队列 可以准时执行每一帧

      // 预防兼容性不好处理方法
      window.requestlAnimationFrame = function() {
        return (
          window.requestAnimationFrame ||
          function(id) {
            window.setTimeout(id, 1000/ 60);
          }
        );
      };
      window.cancelAnimationFrame = function() {
        return (
          window.cancelAnimationFrame ||
          window.webkitCancelAnimationFrame ||
          function(id) {
            window.clearTimeout(id);
          }
        );
      };
    </script>
  </body>
</html>

```

### 7.localStorage和sessionStorage

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
  </head>
  <style>
  </style>
  <body>
    <script>
      // cookie 每次请求都会发送给服务器 很浪费
      // localStorage 长期存放 直接存在浏览器 kv形式
      localStorage.name = "hehe";
      // 两者相等
      localStorage.setItem = ("name","hehe");

      // 只能存取字符串 所以利用JSON.stringify and JSON.parse 转换
      // sessionStorage 短期存放 每次窗口关闭自动清空 
      // localStorage 和 cookie
      // 1.localStorage在发送请求时候不会把数据发出去，cookie会把所有数据发出去
      // 2.cookie存储的内容比较少 4k左右，localStorage 5M

      // localStorage只能存在相同域下（相同协议 相同域名 相同端口）
    </script>
  </body>
</html>

```

### 8.history

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
  </head>
  <style>
  </style>
  <body>
    <input type="text" id="search"><button onclick="search()">搜索</button>
    <div id="main"></div>
    <script>
      // A页面 跳转到B页面 跳转到C页面
      // 为了网页的性能，进行单页面操作
      var data = [{
        name: "HTML"
      },{
        name: "CSS"
      },{
        name: "JS"
      }];
      function search(){
        var value = document.getElementById("search").value;
        var result = data.filter(function(obj){
          if(obj.name.indexOf(value) > -1){
            return obj;
          }
        });
        render(result);
        // 当前页面操作状态 第二个不用 第三个url
        history.pushState({inpVal:value},null,"#"+value)
      }
      function render(renderData){
        var content = "";
        console.log(renderData)
        for(var i = 0;i < renderData.length;i++){
          content += "<div>"+renderData[i].name+"</div>";

        }
        document.getElementById("main").innerHTML= content;
      }
      render(data);
      window.addEventListener("popstate",function(e){
        document.getElementById("search").value = e.state.inpVal;
        var value = document.getElementById("search").value;
        var result = data.filter(function(obj){
          if(obj.name.indexOf(value) > -1){
            return obj;
          }
        });
        render(result);
      })
      window.addEventListener("hashchange",function(e){
        document.getElementById("search").value = e.state.inpVal;
        var value = document.getElementById("search").value;
        var result = data.filter(function(obj){
          if(obj.name.indexOf(value) > -1){
            return obj;
          }
        });
        render(result);
      })
      // 用上面的例子创建搜索后 回退功能 
      // history.back() 回退
      // 只要url变化就会出发 pop事件 
      // hash值（锚点）变化 触发hashchange
    </script>
  </body>
</html>

```

### 9.worker

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
  </head>
  <style></style>
  <body>
    <script>
      // js都是单线程的
      // 但出了worker是多线程的（浏览器兼容差）
      // worker不能操作dom，没有window对象，不能读取文件，可以发ajax 异步计算
      console.log("======");
      console.log("======");
      var a = 100000;
      var worker = new worker("./worker.js");
      worker.postMessage({
        num: a
      });
      worker.onMessage = function(e) {
        console.log(e.data);
      };
      worker.terminate()//停止工作
      console.log("======");
      console.log("======");
    </script>
    <script>
      // ./worker.js
      // 理论上可以worker可以套worker 实际上没有浏览器支持
      importScripts("./##.js")// 通过该方法引入其他js文件 也是不能操作dom等等
      this.onmessage = function(e) {
        var result = 0;
        for (var i = 0; i < e.data.num; i++) {
          result += i;
        }
        this.postMessage(result);
        this.close()// 自己停止
      };
    </script>
  </body>
</html>

```

