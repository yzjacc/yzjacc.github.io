---
layout: post
title: "「ES6」ES6 理论篇 解构与符号"
subtitle: " From Yuzj"
author: "Yuzj"
header-img: "img/post-bg-web.jpg"
header-mask: 0.3
catalog: true
tags:
- ES6
- Javascript
---

## 解构

### 对象解构

**## 什么是解构**

使用ES6的一种语法规则，将一个对象或数组的某个属性提取到某个变量中

***\*解构不会对被解构的目标造成任何影响\****

**## 在解构中使用默认值**

```javascript
const user = {
    name: "kevin",
    age: 11,
    sex: "男",
    address: {
        province: "四川",
        city: "成都"
    }
}

// let name, age, sex, address;
// name = user.name;
// age = user.age;
// sex = user.sex;
// address = user.address;

// let name, age, sex, address, abc;
// ({ name, age, sex, address } = user);

// 先定义5个变量，然后从对象中读取同名属性，放到变量中
let { name, age, sex, address, abc = 123 } = user

console.log(name, age, sex, address, abc)
```

**## 非同名属性解构**

```javascript
const user = {
    name: "kevin",
    age: 11,
    sex: "男",
    address: {
        province: "四川",
        city: "成都"
    }
}
// 先定义4个变量：name、age、gender、address
// 再从对象user中读取同名属性赋值（其中gender读取的是sex属性）
let { name, age, sex: gender = 123, address } = user

console.log(name, age, gender, address)
```

```js
const user = {
    name: "kevin",
    age: 11,
    sex: "男",
    address: {
        province: "四川",
        city: "成都"
    }
}
//解构出user中的name、province
//定义两个变量name、province
//再解构
const { name, address: { province } } = user;

console.log(name, address, province)
```

### 数组解构

 正常解构

```js
const numbers = ["a", "b", "c", "d"];

// const {
//     0: n1,
//     1: n2
// } = numbers;

// let n1, n2;
// ([n1, n2] = numbers);

const [n1, n2] = numbers;

console.log(n1, n2)
```

跨索引解构

```js
const numbers = ["a", "b", "c", "d"];


const [n1, , , n4, n5 = 123] = numbers;

console.log(n1, n4, n5)
```

嵌套解构

```js
// const numbers = ["a", "b", "c", "d", [1, 2, 3, 4]];

// // 得到numbers下标为4的数组中的下标为2的数据，放到变量n中
// const [, , , , [, , n]] = numbers;

// console.log(n)

const numbers = ["a", "b", "c", "d", {
    a: 1,
    b: 2
}];

//得到numbers下标为4的数组的属性a，赋值给变量A
// const [, , , , { a: A }] = numbers;

const { a: A } = numbers[4];

console.log(A)
```

组团解构

```javascript
const user = {
    name: "kevin",
    age: 11,
    sex: "男",
    address: {
        province: "四川",
        city: "成都"
    }
}

//解构出name，然后，剩余的所有属性，放到一个新的对象中，变量名为obj
// name: kevin
// obj : {age:11, sex:"男", address:{...}}

const { name, ...obj } = user;

console.log(name, obj)
```

```javascript
const numbers = [324, 7, 23, 5, 3243];

// 得到数组前两项，分别放到变量a和b中，然后剩余的所有数据放到数组nums

// const [a, b, ...nums] = numbers;

const a = numbers[0], b = numbers[1], nums = numbers.slice(2);//以前的写法

console.log(a, b, nums);
```

变量交换

```javascript
let a = 1, b = 2;

[b, a] = [a, b]

console.log(a, b)
```

### 参数解构

```js
// function print(user) {
//     console.log(`姓名：${user.name}`)
//     console.log(`年龄：${user.age}`)
//     console.log(`性别：${user.sex}`)
//     console.log(`身份：${user.address.province}`)
//     console.log(`城市：${user.address.city}`)
// }

function print({ name, age, sex, address: {
    province,
    city
} }) {
    console.log(`姓名：${name}`)
    console.log(`年龄：${age}`)
    console.log(`性别：${sex}`)
    console.log(`身份：${province}`)
    console.log(`城市：${city}`)
}

const user = {
    name: "kevin",
    age: 11,
    sex: "男",
    address: {
        province: "四川",
        city: "成都"
    }
}
print(user)
```

```javascript
// function ajax(options) {
//     const defaultOptions = {
//         method: "get",
//         url: "/"
//     }
//     const opt = {
//         ...defaultOptions,
//         ...options
//     }
//     console.log(opt)
// }

function ajax({
    method = "get",
    url = "/"
} = {}) {
    console.log(method, url)
}

ajax()
```

## 符号



1.类声明不会被提升，与 let 和 const 一样，存在暂时性死区

2.类中的所有代码均在严格模式下执行

3.类的所有方法都是不可枚举的

4.类的所有方法都无法被当作构造函数使用

5.类的构造器必须使用 new 来调用

```js
class Animal {
    constructor(type, name, age, sex) {
        this.type = type;
        this.name = name;
        this.age = age;
        this.sex = sex;
    }

    print() {
        console.log(`【种类】：${this.type}`);
        console.log(`【名字】：${this.name}`);
        console.log(`【年龄】：${this.age}`);
        console.log(`【性别】：${this.sex}`);
    }
}

const a = new Animal("狗", "旺财", 3, "男");
a.print();

for (const prop in a) {
    console.log(prop)
}
```

### 类的其他书写方式

1.可计算的成员名

```js
const printName = "print";

class Animal {
    constructor(type, name, age, sex) {
        this.type = type;
        this.name = name;
        this.age = age;
        this.sex = sex;
    }

    [printName]() {
        console.log(`【种类】：${this.type}`);
        console.log(`【名字】：${this.name}`);
        console.log(`【年龄】：${this.age}`);
        console.log(`【性别】：${this.sex}`);
    }
}

const a = new Animal("狗", "旺财", 3, "男");
a[printName]();
```

2.getter和setter



类似 ES5 Object.defineProperty 可定义某个对象成员属性的读取和设置



使用getter和setter控制的属性，不在原型上

```js
const printName = "print";

class Animal {
    constructor(type, name, age, sex) {
        this.type = type;
        this.name = name;
        this.age = age;
        this.sex = sex;
    }

    //创建一个age属性，并给它加上getter，读取该属性时，会运行该函数
    get age() {
        return this._age + "岁";
    }

    //创建一个age属性，并给它加上setter，给该属性赋值时，会运行该函数
    set age(age) {
        if (typeof age !== "number") {
            throw new TypeError("age property must be a number");
        }
        if (age < 0) {
            age = 0;
        }
        else if (age > 1000) {
            age = 1000;
        }
        this._age = age;
    }

    [printName]() {
        console.log(`【种类】：${this.type}`);
        console.log(`【名字】：${this.name}`);
        console.log(`【年龄】：${this.age}`);
        console.log(`【性别】：${this.sex}`);
    }
}

var a = new Animal("狗", "旺财", 3, "男");

```

3.静态成员



构造函数本身的成员



![屏幕快照 2019-12-02 下午4.12.56](https://pg12138.oss-cn-beijing.aliyuncs.com/img/in-post/2019-12-2/屏幕快照 2019-12-02 下午4.12.56.png)使用static关键字定义的成员即静态成员

```js
class Animal {
    constructor(type, name, age, sex) {
        this.type = type;
        this.name = name;
        this.age = age;
        this.sex = sex;
    }

    print() {
        console.log(`【种类】：${this.type}`);
        console.log(`【名字】：${this.name}`);
        console.log(`【年龄】：${this.age}`);
        console.log(`【性别】：${this.sex}`);
    }
}

var a = new Animal("狗", "旺财", 3, "男");


class Chess {
    constructor(name) {
        this.name = name;
    }

    static width = 50;//字段初始化器

    static height = 50;//字段初始化器

    static method() {

    }
}

console.log(Chess.width)
console.log(Chess.height)

Chess.method();

```

4.字段初始化器（ES7）



注意：



1). 使用static的字段初始化器，添加的是静态成员

2). 没有使用static的字段初始化器，添加的成员位于对象上

3). 箭头函数在字段初始化器位置上，指向当前对象

```js
class Test {

    constructor() {
        this.a = 123;
    }

    print = () => {
        console.log(this.a)
    }
}

const t1 = new Test();
const t2 = new Test();
console.log(t1.print === t2.print)
```

5.类表达式

```js
const A = class { //匿名类，类表达式
    a = 1;
    b = 2;
}

const a = new A();
console.log(a)
```

6.[扩展]装饰器（ES7）(Decorator)

横切关注点 问题 

装饰器的本质是一个函数

```js
class Test {

    @Obsolete
    print() {
        console.log("print方法")
    }
}
function Obsolete(target, methodName, descriptor) {
  	//类本身 方法名字 方法的装饰对象
    // function Test
    // print
    // { value: function print(){}, ... }
    // console.log(target, methodName, descriptor);
    const oldFunc = descriptor.value
    descriptor.value = function (...args) {
        console.warn(`${methodName}方法已过时`);
        oldFunc.apply(this, args);
    }
}
```



### 类的继承

如果两个类A和B，如果可以描述为：B 是 A，则，A和B形成继承关系



如果B是A，则：



1. B继承自A

2. A派生B

3. B是A的子类

4. A是B的父类



如果A是B的父类，则B会自动拥有A中的所有实例成员。



**源代码**

![屏幕快照 2019-12-02 下午4.55.04](https://pg12138.oss-cn-beijing.aliyuncs.com/img/in-post/2019-12-2/屏幕快照 2019-12-02 下午4.55.04.png)

**继承后**

![屏幕快照 2019-12-02 下午4.55.37](https://pg12138.oss-cn-beijing.aliyuncs.com/img/in-post/2019-12-2/屏幕快照 2019-12-02 下午4.55.37.png)

```js
// ES5 写法
function Animal(type, name, age, sex) {
    this.type = type;
    this.name = name;
    this.age = age;
    this.sex = sex;
}
Animal.prototype.print = function () {
    console.log(`【种类】：${this.type}`);
    console.log(`【名字】：${this.name}`);
    console.log(`【年龄】：${this.age}`);
    console.log(`【性别】：${this.sex}`);
}

function Dog(name, age, sex) {
    //借用父类的构造函数
    Animal.call(this, "犬类", name, age, sex);
}

Object.setPrototypeOf(Dog.prototype, Animal.prototype);//前者的__proto__指向后者

const d = new Dog("旺财", 3, "公");
d.print();
console.log(d);

```

\- super

  \- 直接当作函数调用，表示父类构造函数

  \- 如果当作对象使用，则表示父类的原型

注意：ES6要求，如果定义了constructor，并且该类是子类，则必须在constructor的第一行手动调用父类的构造函数

如果子类不写constructor，则会有默认的构造器，该构造器需要的参数和父类一致，并且自动调用父类构造器

```js
// ES6 实现 
class Animal {
    constructor(type, name, age, sex) {
        this.type = type;
        this.name = name;
        this.age = age;
        this.sex = sex;
    }

    print() {
        console.log(`【种类】：${this.type}`);
        console.log(`【名字】：${this.name}`);
        console.log(`【年龄】：${this.age}`);
        console.log(`【性别】：${this.sex}`);
    }

    jiao(){
        throw new Error("动物怎么叫的？");
    }
}

class Dog extends Animal {
    constructor(name, age, sex) {
        super("犬类", name, age, sex);
        // 子类特有的属性
        this.loves = "吃骨头";
    }

    print(){
        //调用父类的print
        super.print();
        //自己特有的代码
        console.log(`【爱好】：${this.loves}`);
    }

    //同名方法，会覆盖父类
    jiao(){
        console.log("旺旺！");
    }
}

const d = new Dog("旺财", 3, "公");
d.print();
console.log(d)
d.jiao();
```

 【冷知识】

\- 用JS制作抽象类

\- 抽象类：一般是父类，不能通过该类创建对象

\- 正常情况下，this的指向，**this始终指向具体的类的对象**   如果参数只有一个，可以省略小括号

```js
class Animal {
    constructor(type, name, age, sex) {
        if (new.target === Animal) {
            throw new TypeError("你不能直接创建Animal的对象，应该通过子类创建")
        }
        this.type = type;
        this.name = name;
        this.age = age;
        this.sex = sex;
    }

    print() {
        console.log(`【种类】：${this.type}`);
        console.log(`【名字】：${this.name}`);
        console.log(`【年龄】：${this.age}`);
        console.log(`【性别】：${this.sex}`);
    }

    jiao() {
        throw new Error("动物怎么叫的？");
    }
}

class Dog extends Animal {
    constructor(name, age, sex) {
        super("犬类", name, age, sex);
        // 子类特有的属性
        this.loves = "吃骨头";
    }

    print() {
        //调用父类的print
        super.print();
        //自己特有的代码
        console.log(`【爱好】：${this.loves}`);
    }


    //同名方法，会覆盖父类
    jiao() {
        console.log("旺旺！");
    }
}

//下面的代码逻辑有误
const a = new Dog("旺财", 3, "公")
a.print();
```
