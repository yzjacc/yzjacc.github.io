---
layout: post
title: "「Dart」Dart入门"
subtitle: " From Yuzj"
author: "Yuzj"
header-img: "img/post-bg-web.jpg"
header-mask: 0.3
catalog: true
tags:
- Dart
---

dart 与 flutter入门 
Flutter基于Dart语言，在它身上能找到许多js和java的影子，就像TS一样，所以如果学过TS或者Java，很多内容理解起来会更容易。

- Dart既支持弱类型，也支持强类型，所以在声明时，你可以指定具体的类型，如int, String，也可以var一招鲜。当然这会影响预编译阶段的类型推断，指定类型可以帮助你在编写阶段发现问题。
- Dart支持范型，在js里没有这个概念，但是在TS和Java里面都有，这个主要是用于类型推断和减少代码量。比如一个数据，在js里面可能出现各种各样的类型，在dart里可以通过范型List<Int>来表明这是一个int型数组。
- 基本的条件分支判断语法（if,else,for, while,swicth）是一致的，这就足够了。但需要注意的是dart里面只有bool型的true是true，其他都是false。
- Dart里面有类似Promise的Feature，初步感觉就是改了个名字。
- 函数声明不需要function关键字。支持箭头函数，但是和js的箭头函数有区别。
```dart
(a) => {a*a} // 箭头函数
() {return a* a} // 普通函数
```
箭头函数可以里面为普通函数的缩写，如上例。但是当{}里存在两行以上代码时，不能使用箭头函数。
- Dart里面新增了很多没见过的语法，但是不了解这些语法并不影响学习Flutter，它们一般都有替代品。比如
```dart
expr1 ?? expr2  // 实际就是expr1 ？ expr1 ： expr2的缩写
foo?.bar // 实际就是 foo==null ? null : foo.bar的缩写
```
运行与调试
```dart
main.dart
void main(){
  print('hello world')
}
```
运行
```dart
dart ./main.dart // hello world
```
介绍
类型
Object
所有变量都是object，包括null，number等；
变量类型
会根据字面量进行推导，如：
```dart
string a= '12331'
//or
var a ='1231' // a is inferred as string
```
不想指定类型时，可以使用动态类型
```dart
dynamic a ='1212';
a=1212 //is ok
```
变量没有给定初始值，变量类型默认为dynamic
```dart
var a；//a->dynamic
```
在ts中，变量也会根据初始值进行推导，没有初始值默认为any；
```dart
var a='hello'; // a->string

var b;//b->any
```
类型判断
dart中的类型比较简单
```dart
string a= '12331'
assert(a is String); // true
assert(a is Object);; // true Object 是 String的父类，所以类型能 
assert(a is! Number); // true
```
类型定义
dart中使用typedef 定义一个类型（ts中使用type）
```dart
typedef SayHello = String Function(String a);
SayHello sayHello = (a) => a;

//below is ts
type SayHello=(a:string)=>string;
const sayHello: ISayHello = a => a;
```
泛型
```dart
typedef SayHello<T> = String Function(T a);

SayHello<String> sayHello = (a) => a;

//below is ts
type SayHello<T>=(a:T)=>string;
const sayHello: SayHello<string> = a => a;
```
内置类型
- string
- number
- list
- map
- boolean
- runes
- symbol
打印
```dart
// js
console.log('hello world');

// dart

print('hello world')
```
变量
变量默认值
dart中如果定义了一个变量没有指定初始值，那么这个变量的默认值是null；
```dart
var a；
assert(a==null);
```
定义常量
dart中使用const以及final来定义常量
```dart
final name='rujun';
name='zhaorujun'; //error;

//const 
const name='rujun';
name='zhaorujun'; //error;
```
const与final有什么区别？const是编译时的常量，final不是，可以认为const更加严格的常量定义；
```dart
var sayName =（）=>'rujun';

final name1='rujun';
final name2=sayName();

const name3='rujun';
const name4=sayName() // error 必须要在运行时才能确定sayName的值，所以这里会报错
```
从以上可以看出，ts中的const更加接近dart中的final；
空值
null
dart的空置只有一个null；
非空判断
在dart中，进行空值判断没有js那么多花里胡哨的magic(隐式转换)：
```dart
var a;

a='';
assert(a==null) // false
assert(a==0)// false
assert(a==false) // false
assert(a==[]) // false
if(a){ }// error
```
函数
返回值与类型
下面是定义一个函数
```dart
String saName(String name){
    return name
}
```
在dart中，函数也是一个对象，如果不指定函数的返回类型，函数的返回类型默认为dynamic；
```dart
saName(String name){
    return name
}// sayName（String name）->dynamic
```
如果函数中没有返回，默认返回null
```dart
sayName(){} //=>null
```
而在ts中，如果不指定函数的返回类型，ts会自动进行类型推断：
```dart
function sayName(name: string){
    return name
}// sayName（String name）->string
```
箭头函数
与ts一样dart中同样支持箭头函数
```dart
String saName（String name）=> name;//直接返回表达式的值
```
函数参数
dart中支持位置参数以及命名参数两种方式；
```dart
// positioned params
String sayName (String firstName,String lastName)=>firstName + lastName;
sayName('zhao','rujun') // =>'zhaorujun'

// named params
String sayName ({String firstName,String lastName})=>firstName + lastName;
sayName(firstName: 'zhao',lastName: 'rujun')
```
可选参数
位置参数的可选参数
```dart
//位置参数的可选参数
String sayName (String firstName,[String lastName]){
  if(lastName!=null){
    return firstName +lastName;
  }
  else{
    return firstName;
  }
}
sayName('zhao');
//使用可选参数时，一定要对可选参数进行非空判断，否则运行时会报错,ts会在编译报错，这点还是ts好啊
String sayName (String firstName,String lastName)=>firstName + lastName;
sayName('zhao','rujun'); // error
```
对于命名参数，需要修饰符来标记
```dart
String sayName ({@required String firstName,String lastName}){
  if(lastName!=null){
    return firstName +lastName;
  }
  else{
    return firstName;
  }
}
```

默认参数
```dart
//位置参数
String sayName (String firstName,[String lastName = 'name'])=>firstName + lastName;
// 命名参数
String sayName ({String firstName,String lastName='name'})=>firstName + lastName;
作用域与闭包
dart的作用域是词法作用域，这点与ts一样。
markName(String firstName)=>(String lastName)=>firstName+lastName;

var markMyName=markName('zhao');

markMyName('rujun');// =>'zhaorujun'
markMyName('xiaojun');// =>'zhaoxiaojun'
```
异步
dart是一个单线程的语言，在对异步的处理支持显得尤为关键。
Future
dart中的Future与js中的Promise一样，表示未来值
```dart
Future<int> future = getFuture(); 
future.then((value) => handleValue(value))
.catchError((error) => handleError(error));
Future.wait ->Promise.all
var future1=...;
var future2=...;

Future.wait([future1,future2]).then(...)//will excute when all futures complete
Future.any ->Promise.race
var future1=...;
var future2=...;

Future.any([future1,future2]).then(...) //will excute when the first future complete
```
处理以上常用的api外，我们还会常常有把callback转换为promise的需求，在dart中需要用到completer；
```dart
Future time(int time) async {
  Completer c = new Completer();
  new Timer(new Duration(seconds: time), (){
    c.complete('done with time out');
  });
  return c.future;
}

time(1).then(...) // 把timer的callback转换为future
async await
```
类
dart是个一门面向对象语言，支持class以及mixin继承
constructor
```dart
class Point {
  num x, y;
  Point(num x, num y) {
    this.x = x;
    this.y = y;
  }}
// equal to above but shorten and better
class Point {
  num x, y;
  Point(this.x, this.y);
}

// named-contractor
class Point {
  num x, y;
  Point(this.x, this.y);
  // Named constructor
  Point.origin() {
    x = 0;
    y = 0;
  }}
var point = Point.origin();// point->{x:0,y:0}
```
调用父类的constructor
dart中construtor是不能被子类继承的,必须手动调用父类的constructor（在js中也需要）；
```dart
class Person {
  String firstName;
  Person(this.firstName){
    super（）
    print('in Persion');
  }
}

class Employee extends Person {
  Employee.fromJson(Map data) : super('data') {
    print('in Employee');
  }
}
 var emp = new Employee.fromJson({});
// in Persion
// in Employee
```

省略new关键词
值得注意是是，在dart2中，创建实例时，可以省略new关键词
```dart
class Person {
  Person(this.firstName){
    print('in Persion');
  }
}
var person = Person（'myname'）
```
this指向
类内部中，this指向实例。在dart中一般不用this，除非命名冲突；
```dart
class Point {
  num x, y;
  Point(this.x, this.y);
  
 void moveY（num positionY）{
    y=positionY
 }
  
  void moveX（num x）{
    this.x=x;
  }
}
```
```dart
const constructor
```
可以使用const 关键词构造一个实例，这样对象会在编译时置为常量；
```dart
class ImmutablePoint {
  final num x, y;
  const ImmutablePoint(this.x, this.y);
}

var p0 =const ImmutablePoint(0,0)
var p1 =const ImmutablePoint(0,0)
assert(identical(p0, p1)) //true 虽然是不同的引用，但是指向同一个对象
```
属性与方法
在dart中，方法默认是公开的，私有方法与属性使用‘_’前缀修饰，不像ts或者java那样有pulic以及private修饰；
```dart
class Point {
  num _x, _y;
  _move(){
    _x=0;
    _y=0    
  }
}
```
类型判断
判断两个对象的类型是否一致时，可以时用对象的runtimeType方法进行判断；
```dart
class Point {
  num x, y;
  Point(this,x,this.y)
}
var p1=Point(0,0);
var p2=Point(1,1);
assert(p1.runtimeType==p2.runtimeType) // true
```
继承
与ts一样，使用extends关键继承，其中super关键词指向父类；
```dart
class Point {
  num x, y;
  Point（this.x,this.y）
  void moveY(num positionY){
    this.y=positionY;
  }
 }

class BigPoint extends Point{
  BigPoint(num x,num y):super(x,y);// 调用父类的constructor
  void moveY(num positionY){
    super.moveY(positionY); // 调用父类的方法
  }
}
```
mixin
在dart中可以使用with关键词给类添加特征,使用mixin定义一个‘特征’；
```dart
mixin Size{
 final num size =100;
}

class BigPoint extends Point with Size{
  //...
  void getSize(){
    return size // 100;
  }
}
```
模块
模块可见性
dart中单个文件可以作为一个模块，模块内的所有声明都是公开的，可以使用‘_’修饰表示私有模块；
```dart
//bar.dart
String sayBar(){
    return 'bar'
}
String _sayHello(){
    return 'bar'
} // private
```
引入模块
使用import引入模块或者包,
```dart
//foo.dart 
import './bar.dart'
sayBar() // 'bar' 

 // or import a package
import 'package:test/test.dart'
test()//
```
如果只想引入部分可以使用show 或者 hide
```dart
//foo.dart 
import './bar.dart' show sayBar 
sayBar() // 'bar' 
```
与ts一样，可以给模块起别名
```dart
//foo.dart 
import './bar.dart' as bar
bar.sayBar() // 'bar' 
```
异步模块
dart中支持异步加载模块；
```dart
import './bar.dart' deferred as bar;

Future say() async {
  await bar.loadLibrary();
  bar.sayBar() // 'bar' 
}
```
包管理
dart里面的包管理与js生态的npm包管理十分相似；
安装外部包
使用外部包时，需要在pubspec.yaml文件添加相应的包名；
ps：yaml有严格的缩进要求
name: hello_world
description: A new Flutter project.
environment:
  sdk: ">=2.0.0-dev.68.0 <3.0.0"
dependencies:
   vector_math: ^2.0.7
dev_dependencies:  
   test: ^1.0.0
运行
pub get  // 与npm install相似
pub命令
Available commands:
  cache       Work with the system cache.
  deps        Print package dependencies.
  downgrade   Downgrade the current package's dependencies to oldest versions.
  get         Get the current package's dependencies.
  global      Work with global packages.
  help        Display help information for pub.
  publish     Publish the current package to pub.dartlang.org.
  run         Run an executable from a package.
  upgrade     Upgrade the current package's dependencies to latest versions.
  uploader    Manage uploaders for a package on pub.dartlang.org.
  version     Print pub version.
异常
异常类型
在dart中有Exception 以及 Error两种类型；
其中Exception 派生的内置Exception 有：
DeferredLoadException
FormatException
IntegerDivisionByZeroException
IOException
IsolateSpawnException
TimeoutException
异常抛出
可以抛出一个Exception
throw FormatException('Expected at least 1 section');
或者直接抛出任意的对象
throw 'Out of llamas!';
异常捕获
on TimeoutException
开发包
开发dart详细教程可以戳这里
开发dart中文官网可以戳这里
开发dart资源包可以戳这里

知识点
Flutter技术优势
Flutter是彻底的跨平台方案，既没有采用webView，也没有采用JS桥接原生控件，而是自行实现一套UI框架，在引擎底层通过Skia渲染到屏幕。对于UI之外所需要使用的移动设备自身提供的服务，比如相机、定位、屏幕触摸等，则采用Platform Channels跟原生系统通信的方式来实现。

对于Flutter优势，回到前面讲到移动端技术选型的4要素，研发效率、动态性、多端一致性、性能体验，分别对应下面这一组词语。
|

1. 高效率：采用dart语言编写代码，虽然刚开始上手需要点时间，但熟练后效率比较高。一套代码适用多个平台(Android、iOS、Web)，以及高效的Hot Reload能快速辅助调试；
2. 动态化：2017年3月苹果下发警告邮件，禁止JSPatch等 iOS App热更新方案，从此iOS动态化成为一个不宜公开讨论的话题。同样地，Flutter引擎在某一个官方版本对动态化做过一些尝试，但后续基于风险考虑移除，当然并没有阻碍大家对技术的探索，这里不方便展开讨论；
3. 高一致性：实现UI像素级的控制，Flutter渲染引擎依靠跨平台Skia图形库来实现，仅依赖系统图形绘制相关的接口，比如未来Android会支持vulkan，iOS会支持metal，这些都是通过skia封装调用。可最大程度上保证不同平台的体验一致性，见下图所示。
|

4. 高性能：渲染性能优于现有的各种跨平台框架，可媲美原生性能的跨平台技术方案，Dart代码执行效率比JS高，通过AOT编译成平台原生代码，渲染采用自渲染skia方案，既不需要JS Bridge桥接，也不需要Art虚拟机参与。再从渲染原理来看看Flutter的高性能的底气在哪里。
|
图解：
- Android原生框架，通过调用Java Framework层，再调用到skia来渲染界面；
- 其他跨平台方案(如RN)，通过JSBridge中间层来将JS写的APP转换成相应的原生渲染逻辑，可见比Native代码增加了更多逻辑，性能逊色差于原生框架；
- Flutter框架，APP通过调用Dart Framework层，再直接调用到skia来渲染界面，并没有经过原生Framework过程，可见其渲染性能并不会弱于Native技术，这是一个性能上限很高的跨平台技术。

当然，不得不说目前的Flutter确实不够尽善尽美，会存在一些不够尽善尽美之处，比如生态不够健全，包体积问题，但其该方案的上限比较高，想象空间比较大，相信更多开发者参与进来，经过更多打磨，未来会做得更好。
1. 工程结构
使用Android Studio创建的纯Flutter工程，我们可以得到以下工程结构。
|
主要文件介绍：
> .flutterw：flutterw配置以及flutter引擎混存目录
> android：android宿主工程目录
> ios: ios宿主工程目录
> lib：代码目录
    main.dart: 代码实例，亦是一个完整的应用。
> test: 测试代码目录
pubspec.yaml文件：项目配置文件，声明依赖、资源、项目信息等
2. 一切皆Widget
Flutter中，一切界面元素都是Widget，一个App都属于一棵Widget树。
|
3. 组合 > 继承
在Flutter中，强调组合大于集成，所以每个Widget的功能很轻量很单一，例如一个Padding就是一个Widget。
这一点和Android的View体系设计截然不同，Android中，View功能复用主要通过继承来实现，因为要复用文字功能，所以Button继承TextView，这样的显然不是那么合理，因为Textview中大量的文字处理能力，包括复制等其实Button是用不到的，而且当我们要实现其他定制的按钮（如ImageButton），又得完全实现一个派生类，这显然是不科学的。
Flutter吸取了这些不好的经验，强调组合实现所有功能，在Flutter中，Button就是负责点击效果的，它可以组合一个Text（文字Widget），成为一个带文字的按钮，也可以组合一个Image（图片Widget），成为一个带图片的按钮，可以组合任何东西，实现高可定制的按钮。
正因为高组合性，我们可以轻松实现几乎所有视觉效果，而不用考虑实现一个自定义Widget。
不过这样做的劣势也是有的，我们的代码嵌套层级可能很深，如一个带Padding的图片按钮至少得嵌套3层：
```dart
Button(
    child: Padding(
        child: Image(...),
        ...
    ),
    ...
)
```
整体的代码可读性似乎会变差，这一问题Google正在通过优化语言语法糖、优化IDE体验进行改善。但对于我们，我们可以通过抽离语义完整的Widget控件最大的优化这一问题，例如上面这个图片按钮就是一个完整语义，我们就可以定义一个ImageWidget，然后在界面中直接使用ImageWidget进行开发，这样代码的层级就会好很多了。
4. 声明式UI
前面聊了Flutter中的Widget和Android中的View的区别，他们的区别从本质上来看其实是声明式编程和命令式编程的区别。下面我们通过例子简单聊聊声明式编程和命令式编程的区别，下图例子中，我们需要把左边的界面变成右边的界面。

命令式编程，我们会写类似于下面的代码，主动改变b的颜色，清除孩子节点，增加新的孩子节点。
```dart
// Imperative style
b.setColor(red)
b.clearChildren()
ViewC c3 = new ViewC(...)
b.add(c3)
```
那么声明式编程应该怎么写呢？下面这样写。
```dart
// Declarative style
return ViewB(
  color: red,
  child: ViewC(...),
)
```
直接描述新的状态就好了，b是红色，孩子节点是c。
只要声明好状态，UI系统就会自动进行视图变更，无需我们手动输入变更命令，这就是声明式UI。也就是说，在Flutter的UI开发中，我们只需要声明当前状态即可。
5. 三棵树
声明式UI始终声明的是最新状态，为了避免混淆，下面使用待变更状态来指代，变更前状态称为当前状态。
我们仅需声明待变更状态，UI系统就会自动进行试图变更，显然是系统会自动去识别当前状态改怎么变成待更新状态，并执行相应的刷新操作真正的View树进行变更。所以，Flutter框架内其实维护着一棵真正的View逻辑树，这棵View树被称为Element Tress。
Widget也会形成Widget Tree，并且与Element Tree对应节点关联起来，每次rebuild后，Flutter框架会对前后两棵Widget树进行Diff，这样能快速找到需要变更的节点，然后操作其对应的Element节点进行更新。
Element Tree作为View逻辑树，它仅仅负责了逻辑结构，但具体的渲染它也进行了分离，分理出一棵Render Tree，因为并不是所有节点都需要渲染的，所以Element Tree和Render Tree并非一对一的关系。
|

以上基本就是这三棵树的基本介绍了，正是有这三棵树的互相配合，系统帮我们自动维护好视图的变更。
6. 关于Key
编写Widget的时候，我们会发现每个Widget都能传一个Key，怎么理解这个Key呢？前面我们聊到三个树会自动帮我们去判断Widget有没有更新，主要判断逻辑如下：
新Widget对应已有Widget操作存在不存在新增节点，挂载新节点不存在存在删除该节点存在存在判断是否要更新状态，如需要则执行更新操作这里面每种情况如何处理已经很明了，但怎么找到对应的Widget进行对比呢？Flutter框架提供默认的寻找方式是根据类型和相对位置来对比，一般情况下就能锁定关联Widget，但在特殊情况下，如类型相同的两个Widget交换了位置，这样Flutter框架就不能很好的识别，导致关联出错，这里有一个视频详细介绍了这种情况https://api.flutter.dev/flutter/foundation/Key-class.html。
所以，为了协助Flutter框架识别出对应的Widget，Flutter提供了一套Key体系，但我们默认的识别手段失效时，就需要明确设置一个Key帮助Flutter进行判断。根据搜索范围的差异Key体系包括了：GlobalKey和LocalKey两种。

Android的Jetpack Compose提供了另外一种思路来帮助系统识别对应的节点，编译期通过对代码进行代码块ID注入，然后通过注入的ID进行直接对比，这种方案更加高效而且开发无感。
7. 单线程模型
Flutter使用Dart作为基础开发语言，Dart是相对极端的单线程语言，去掉了线程的概念，提供一个isolate概念，isolate之间内存不共享，更像是进程。所以，相比于其他平台强调主线程操作UI，Flutter从语言基础做了这个限制，一般情况我们的代码只跑在唯一isolate上。

但是单线程如何处理异步事件呢？至少网络请求需要等待结果才能进一步处理，总不能一直阻塞着吧。于是，Dart引入了协程的处理方式，把需要异步的操作打包成一个异步事件，这个异步事件包含了异步操作的所有上下文，当异步操作需要阻塞时，就会把这个异步事件上下文打包挂起在消息队列上，不影响这个事件以外的操作继续处理，等异步事件需要继续往下处理时，就会在下一个run loop进行处理，如下图：
|


所以，这里要注意的是，在Flutter开发中，我们调用一个异步方法（async function or Future），它其实还是在当前isolate进行操作的，也就是说，这里面还是不能写一些耗时操作，例如解析json等。但我们真的需要做耗时操作，可以考虑另起一个isolate，dart也提供了比较简便的compute方法进行支持：
// 完整例子可以参考：https://flutter.dev/docs/cookbook/networking/background-parsing
Future<List<Photo>> fetchPhotos(http.Client client) async {
  final response =
      await client.get('https://jsonplaceholder.typicode.com/photos');

  // Use the compute function to run parsePhotos in a separate isolate.
  return compute(parsePhotos, response.body);
}
另外，还需要特别留意的是，调用一个async function，会直接执行其方法体，直到遇到await方法，才会把这个async function整个打包打入消息队列中。
其他
更多Flutter的基础知识请移步：https://flutter.dev/docs/development，或留言进行讨论。
